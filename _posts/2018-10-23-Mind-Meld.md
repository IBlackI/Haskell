---
layout: post
title: The Mind Meld
---
Het laatste hoofdstuk uit het boek. Ik merk tot nu toe dat de materie steeds complexer wordt. Ik hoop dat ik dit hoofdstuk nog ga begrijpen want van wat ik gehoord heb is deze vrij pittg.  

# Classes and Types

De basic types hebben wij al tijdens de eerste blog gezien, als korte herhaling zijn bijvoorbeeld een Bool en Char primitive types. Een String is een lijst van Char.

## User-Defined Types

Het is in Haskell mogelijk om zelf een Type te definieren, dit gaat doormiddel van onderstaande syntax
```
data %name% = Type (| Type)
```
waarbij `%name%` aangeeft hoe het type moet gaan heten.
Het is verplicht minimaal 1 ander Type aan te geven waaruit jou Type kan bestaan. Met het `|` teken kan je aangeven dat jou type uit één de aangegeven Types kan bestaan. Een Tupel of Lijst is ook een type. Het is dus mogelijk om bijvoorbeeld de volgende Type te definieren:
```
type Adres = (String, Number)
```
Een adres bestaat nu dus uit een tupel met daarin een String (straatnaam) en Number (huisnummer). String en Nummer zijn beide echter geen primitieve waarde. Het Type systeem van Haskell vertaald uiteindelijk alle types naar primitieve waarden.

## Recursieve Types

Het is in Haskell ook mogelijk om een recursief type te definieren. In de lessen hebben wij tijdens het bouwen van een grammatica iets gezien wat hier op lijkt. Bijvoorbeeld een som, een som is een samenvoeging van twee getallen, maar een som kan ook een getal en een resultaat van een andere som samenvoegen. In haskell zou dat er ongeveer zo uit zien. (deze som is niet berekend maar geeft alleen twee waardes die samengevoegd zouden moeten worden)

```
data Tellable = Tell Integer | Som deriving (Show)
data Som = TelOp Tellable Tellable deriving (Show)
```

Helaas is het mij niet gelukt om dit voorbeeld werkend te krijgen.

## Classes
maar dan niet in de Object Orientend manier. Mocht je het toch met OO willen vergelijken dan komt een Interface nog het dichtste bij. Een Class is een Type die een implementatie voor alle function signatures heeft. Het boek gaat niet verder op een uitwerking in.

## Monads
Eindelijk een compleet nieuwe term.
>  But you’ll probably find that you need to wade through several examples from many different sources to come to an understanding of what monads can dofor you.
Helaas zal ik het alleen met dit boek moeten doen door gebrek aan tijd. 

In javascript ben ik het vaker tegengekomen dat je een functie een reference naar een variabele meegeeft, de functie bewerkt de variabele per referentie. [Artikel hier over](https://codeburst.io/javascript-pass-by-value-and-pass-by-reference-in-javascript-fcf10305aa9c) Het voorbeeld uit het boek met de piraat zou er dus ook zo uit zien:
```
-- d is een object met daar in een nummer en kan dus als reference meegegeven worden
stagger(d)
crawl(d)
stagger(d)
```

In haskell bestaan echter geen referenties op deze manier en kan je bovenstaande code niet zo uitdrukken. In haskell zal je verder moeten met de waarde van de vorige functie. Dus:
```
stagger(crawl(stagger(d)))
```
of
```
letTreasureMap (v, d) = let d1 = stagger d
d2 = stagger d1
d3 = crawl d2
in d3
```

De oplossing om dit mooier te maken is een Monad. Oftewel " a monad lets us compose functions in ways that have specific properties".
### De uitwerking
```Haskell
module Main where
  data Position t = Position t deriving (Show)
  stagger (Position d) = Position (d + 2)
  crawl (Position d) = Position (d + 1)
  rtn x = x
  x >>== f = f x
```
Als ik dit zie denk ik dat de definitie van mooi toch afwijkt van wat ik in gedachte had, maar goed bovenstaande is dus een hele simpele Monad. Het gebruik van de Monad gaat als volgt:
```HASKELL
treasureMap pos = pos >>==
  stagger >>==
  stagger >>==
  crawl >>==
  rtn
```  
Na redelijk wat tijd en [andere bronnen](https://www.haskell.org/tutorial/monads.html) heb ik nu wel een idee hoe deze monad werkt, hoop ik. Ik begrijp waarom dit een lastig concept is. Ik ga het proberen in eigen woorden uit te leggen.
De monad bestaat uit 3 onderdelen.  
1. De container, oftewel iets wat een waarde kan houden, bijvoorbeeld een lijst of nummer. In bovenstaand voorbeeld een `Position` die waarde `t` kan houden.  
1. Een return functie die de waarde in je monad teruggeeft. 
1. Een functie die andere functies in de monad aan elkaar kan koppelen.
Deze onderdelen samen vormen een Monad. Het voordeel van een Monad is dat je de functies achter elkaar aan kan roepen (composition) in plaats van moet nesten.

## Do
Een andere notatie voor een monad kan met een `do` bijvoorbeeld:
```
module Main where
  tryIo = do putStr "Enter your name: " ;
             line <- getLine ;
             let { backwards = reverse line } ;
             return ( "Hello. Your name backwards is " ++ backwards)
```
Als oefening probeerde ik deze monad om te schrijven naar een monad van de andere notatie. Dit is wat ik dacht dat het zou moeten zijn:
```
module Mon where 
    data Output t = Output t deriving (Show)
    getl (Output d) = Output(getLine : d)
    rtn x = "Your name is" ++ x
    x >>== f = f x
```
Helaas blijkt dit niet te werken omdat getLine een `IO String` terug geeft en `Your name is` is een `[char]` En deze kunnen helaas niet samengevoegd worden. 


