---
layout: post
title: First steps
---

# De Opdracht
Voor ASD-APP moeten wij als opdracht een nieuwe programmeertaal leren. 
Het leerproces moeten wij in blogvorm vastleggen, ik ga dit aan de hand van een Github Pages blog doen.
Helaas konden wij niet elke programmeertaal kiezen maar was de keuze beperkt tot vijf mogelijkheden:  

1. Prolog
2. Scala
3. Erlang
4. Clojure
5. Haskell

Zoals de naam van de blog al deed voormoeden heb ik voor Haskell gekozen, dit omdat ik functioneel programmeren graag een keer zou willen proberen.  

# Haskell
Als eerste heb ik maar gewoon online gezocht naar Haskell [het eerste resultaat](https://www.haskell.org/) heeft op de voorpagina gelijk een een tutorial.  
Een goede start lijkt mij.  

## De tutorial
### Lijsten
Als eerste "regel" werd `5 + 7` voorgesteld. Niet heel ingewikkeld dacht ik, de output was echter compleet anders dan dat ik verwacht had: `12
:: Num a => a`. Gelukkig begint het met 12 zoals ik verwacht had. `:: Num` zal dan wel aangeven dat de 12 een nummer (getal) is, maar `a => a` zegt mij niet zo veel.  

```
λ "Lennard"
"Lennard" :: [Char]
```  
Het invoeren van een stuk tekst ziet Haskell blijkbaar als een lijst van Char, zoals Java een String intern volgens mij ook als een (Array)List van char bijhoudt.

### Functies

```
λ sort [42,13,22]
[13,22,42] :: (Num a, Ord a) => [a]
```

Bij het aanroepen van de `sort` functie op een lijst het blijkbaar niet nodig om de parameters tussen haakjes te zetten in tegen stelling tot veel andere (OO) programmeertalen die ik tot nu toe gebruikt heb.  

```
λ fst (28,"chirs")
28 :: Num a => a
```
De omschrijving van de functie `fst` vind ik wel verassend:  

> It's called "fst" because it's used a lot in Haskell so it really needs to be short!  

Blijkbaar zal er binnen Haskell veel gewerkt worden met tupels, of in ieder geval data representaties waarbij het eerste element van belang is. 

```
λ let x = 8 * 10 in x + x
160 :: Num a => a
```

In deze regel wordt er een variabele x gemaakt en vermenigvuldigd. `let` geeft blijkbaar aan dat iets een variabele is en `in` wat er mee moet gebeuren.

```
λ map (+1) [1..5]
[2,3,4,5,6] :: (Enum b, Num b) => [b]
```
De map functie vind ik qua resultaat en gebruik heel erg lijken de [Javascript Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) de syntax is echter wel compleet anders, hierbij wordt wel tussen haakjes aangegeven wat er met de list moet gebeuren `(+1)` maar niet hoe, bijvoorbeeld `result = entry + 1`, uit nieuwsgierigheid wilde ik testen wat er zou gebeuren als je `(+1)` op een lijst van Char doet. Ik verwachtte dat `"ABC"` dan `"BCD"` zou worden, maar helaas blijkt het alleen op Num te werken.
```
λ map (+1) "abc"
No instance for (Num Char) arising from a use of ‘+’ In the first argument of ‘map’, namely ‘(+ 1)’ In the expression: map (+ 1) "abc"
``` 
Het volgende deel van de tutorial is het definieeren van een functie, bijvoorbeeld:
```
λ let square x = x * x in square 3
9 :: Num a => a
```
dit lijkt heel erg op de syntax van een variabele. `let expression in body` waarbij hier de expression de functie in zijn geheel is. `square x = x * x` en de code waarin de functie gebruikt wordt de body `square 3`.

De functie toUpper veranderd een lowercase char naar een uppercase char, logisch, maar om een hele string naar uppercase te krijgen was het niet mogelijk om `toUpper "Lennard"` te doen. Achteraf is dit logisch omdat "Lennard" een lijst van char is, gelukkig kan het doormiddel van de map functie wel.
```
λ map toUpper "Chris"
"CHRIS" :: [Char]
```

Dat was de vierde les van de tutorial alweer, maar bij het einde viel mij iets (belangrijks) op. 
> Let's go over what you've learned in this lesson:
> 1. Functions like map take other functions as parameters.
> 2. Functions like (+1), (>5) and square can be passed to other functions.   

`+1` is niet de operatie die de map functie op de lijst uit moest voeren, maar de naam van de functie die hij voor elke entry in de lijst moest uitvoeren!

### Pattern matching
```
λ let (a,b) = (10,12) in a * 2
20 :: Num a => a
```
Pattern matching is volgens de tutorial een manier om verschillende entries in een tupel aan een variabele te kunnen koppelen. (zodat je er iets mee kan doen). In bovenstaand voorbeeld `a = 10` en `b = 12`. Voor een lijst is de syntax echter wel anders in onderstaand voorbeeld worden de variabelen niet geschijden met een `,` maar met een `:` daarnaast staat er ook nog een `:[]` achter, waarvoor deze dient weet ik niet. Daarnaast is het mogelijk om alle verdere waarden met een `_` te negeren. Bijvoorbeeld: `λ let (a:_) = "xyz" in a` ik denk dat dit handig is omdat je vaak niet weet hoe lang de input zal zijn.
```
λ let (a:b:c:[]) = "xyz" in a
'x' :: Char
```  

### Reflectie
Het moeilijkste aan Haskell lijkt hem voor mij tot nu toe in de syntax te zitten, de concepten begrijp ik (voor mijn gevoel) wel maar de syntax vind ik vaak niet heel logisch. Ik heb ook het gevoel dat de syntax heel veel impliciet definieerd.  
In de volgende blogpost ga ik beginnen met het hoofdstuk over haskell in het boek.

***
End of post
***

# Primitieve Types
***

In de vorige blogpost heb ik mij via [de website van Haskell](https://www.haskell.org/) in de taal verdiept middels de tutorial. 
Echter moeten wij voor ASD-APP gebruik maken van het boek [Seven Languages in Seven Weeks](https://pragprog.com/book/btlang/seven-languages-in-seven-weeks) geschreven door Bruce Tate.
  
In de tutorial van Haskell heb ik al geleerd over Strings, Lijsten, Functions en Pattern Matching. In deze blogpost begin ik aan Day 1: Logical uit het boek.

# GHCi Installeren  
Voordat ik verder kan met het boek zal ik eerst een Haskell compiler op mijn systeem moeten hebben, de tutorial gebruikte een interactieve in-browser commandline interface, maar het boek gebruikt GHCi.  
GHCi is de (interactieve) compiler van Haskell. De installatie hiervan was simpelweg het [downloaden](https://www.haskell.org/platform/windows.html) van de website en uitvoeren van de installer. De applicatie WinGHCi is de windows variant van de GHCi console die in het boek gebruikt word.

# Herhaling
De eerste 3 hoofdstukken gaan over de primitieve waardes in Haskell dit zijn: 
1. Numbers
1. Character Data
1. Booleans  
Aangezien ik de tutorial al gehad heb zal ik hierbij alleen de dingen behandelen die ik nog niet wist.  
## Numbers
  Dit hoofdstuk bevat geen nieuwe stof, echter valt het mij wel op dat hierbij in de resultaten geen datatypes worden weergegeven in tegenstelling tot de online versie.  
## Character Data
Zoals in de tutorial ook al geleerd is een String een lijst van characters. Twee lijsten zijn ook niet samen te voegen doormiddel van `+`, bijvoorbeeld `"hello" + "world"`. Hier is een speciale operator (of misschien is het een functie) voor namelijk `++`.
## Booleans
Booleans zijn de enige primitieve datatypes die niet in de tutorial behandelt zijn. Hierbij valt gelijk de "niet gelijk aan" operator op. Deze is in veel andere talen `!=`, maar in LUA ben ik gewend dat het `~=` is. Haskell heeft zijn eigen "niet gelijk aan" operator `/=` het eerste wat mij tijdens het typen van deze operator opvalt is dat, in tegenstelling tot `!=` of `~=`, alle benodigde karakters aan de rechterkant van het toetsenbord zitten. De tutorial had het erover dat `fst` zo kort was omdat het vaak nodig is, maar het typen van `/=` gebeurt allebei met mijn rechter pink. Dit heeft als gevolg dat het lastiger en langzamer is om te typen. Een beetje tegenstrijdig, tenzij `/=` nauwlijks gebruikt word natuurlijk.

> In Haskell, if is a function, not a control structure, meaning it returns a value just like any other function.  
  
`if (5 == 5) then "true" else "false"` is dus een voorbeeld van een if functie aanroep, ik neem aan dat `then` en `else` hierbij ook parameters zijn. 

`:set +t` is blijkbaar de optie waarmee de datatypes van de output weer aangezet kunnen worden. 

> Rather than a pure type , you get a class , which is a description of a bunch of similar types. We’ll learn more in Section 8.4, **Classes**, on page 299.  

Bij het woord Classes denk ik gelijk aan de Object georienteerde manier, ik ben benieuwd wat dit in functioneel programmeren inhoud.  

# Functions
In de tutorial is ook kort het maken van een functie voorbij gekomen. Het boek gaat hier dieper op in, maar eerst wisselen we de interactieve GHCi in voor "echte" bestanden. In het boek staan links om de code die getoond wordt te downloaden en zelf te kunnen draaien. In Haskell wordt met modules gewerkt, in een module kunnen meerde regels code staan in tegenstelling tot GHCi waarbij je maar een regel code kan ingeven.  
```
Prelude> :load double.hs
[1 of 1] Compiling Main ( double.hs, interpreted )
Ok, modules loaded: Main.
* Main> double 5
10
```  
  
Helaas werkt bovenstaand voorbeeld niet in mijn Haskell omgeving, na even Googlen blijkt dit er aan te liggen dat de module [niet Main mag heten zonder meerdere regels aan IO code](https://www.reddit.com/r/haskellquestions/comments/3of62e/the_io_action_main_is_not_defined_in_module_main/cvwouf8/). Ik weet niet of dit door een update in Haskell of een fout in het boek komt. Na het aanpassen van de naam van de module werkt het wel. 

```HASKELL
double :: Integer -> Integer
double x = x + x
```

In Java bestaat een functie uit een header en een body bijvoorbeeld
```JAVA
//Header
public function String sayHello(String name) {
  //Body
  return "Hello, " + name;
}
```

Bij Haskell lijkt de Header uit 1.5 regels te bestaan, eerst de naam gevolgd door de types. Dan op de volgende regel weer de naam gevolgd door de body. Het twee keer definieren van de naam lijkt mij dubbel op, maar wellicht heeft dit als voordeel dat je bovenin een bestand alle functies met types kan definieren en pas later in het bestand declareren waardoor je snel zou kunnen zien wat een module kan.

## Recursie
Recusie is een onderwerp waar ik al vaker ervaring mee gehad heb, ik verwacht dat de implementatie hiervan (een functie die zichzelf aanroept) in Haskell niet anders zal zijn dan in andere talen. 
```
Prelude> let fact x = if x == 0 then 1 else fact (x - 1) * x
```
Dit is (behalve dan in 1 regel) zoals ik zou verwachten bij een recursieve functie.

```HASKELL
module Main where
  factorial :: Integer -> Integer
  factorial 0 = 1
  factorial x = x * factorial (x - 1)
```
De functie hierboven is wel anders dan ik zou verwachten, maar met de omschrijving erbij is het best logisch. Als de input `0` is dan is de output `1`. Als de input `x` is, is de output `x * factorial (x - 1)`.

### Guards
```HASKELL
module Main where
factorial :: Integer -> Integer
factorial x 
  | x > 1 = x*  factorial (x - 1)
  | otherwise = 1
```
Guards zijn een principe waarvan ik nog nooit eerder gehoord had, maar de theorie vind ik wel interessant. Een guard is een syntax waarmee je de input eerst kan vergelijken via een expressie en als er true uit komt voert hij de bijbehorende body uit. Ik zie niet wat het voorbeeld is ten op zichte van een if statement, wellicht omdat Haskell geen else if kent?

# Fin
In de volgende blogpost zal ik verder gaan met Day 1: Logical. In deze post is het voornamelijk herhaling geweest van de tutorial, maar er zijn ook zeker interessante nieuwe concepten voorbij gekomen. Ik ben wel van mening dat de syntax nog steeds niet altijd gelijk duidelijk is. 

***
End of post
***

# Tuples and Lists
***
In de vorige twee blogposts zijn de basis van Haskell besproken.   
In deze blogpost ga ik dieper op de taal in. Ook zal het tempo iets hoger liggen dan in de vorige blogposts.  

# Tupels
De tutorial van Haskell heeft tupels al laten zien, echter gaan we er nu gebruik van maken om te rekenen. 
Als voorbeeld zal de [Rij van Fibonacci](https://nl.wikipedia.org/wiki/Rij_van_Fibonacci) gebruikt worden dit is een rij van getallen waarbij elke waarde de som van de twee voorgaande waardes is.  
Recursief zou dit met onderstaand voorbeeld te berekenen zijn.
```
fib :: Integer -> Integer
fib 0 = 1
fib 1 = 1
fib x = fib (x - 1) + fib (x - 2)
```
Deze voorbeeld code heeft als nadeel dat een aanroep met een hoge waarde voor x heel vaak dezelfde waardes van x zal uitrekenen.  
Tijdens het onderwerp algorimtes is geleerd dat elke dubbele functie aanroep vermeden zou moeten worden.  
Gelukkig is deze functie efficienter te maken doormiddel van een tupel.  

## Fibonacci met tupel
Voor het berekenen heeft de tupel 3 waarde nodig (Fib(x-2), Fib(x-1), x). Onderstaand voorbeeld is hier een implementatie van:  
```
fibTuple :: (Integer, Integer, Integer) -> (Integer, Integer, Integer)
fibTuple (x, y, 0) = (x, y, 0)
fibTuple (x, y, index) = fibTuple (y, x + y, index - 1)

fibResult :: (Integer, Integer, Integer) -> Integer
fibResult (x, y, z) = x

fib :: Integer -> Integer
fib x = fibResult (fibTuple (0, 1, x))
```  
het gebruik van twee helperfuncties zorgt ervoor dat het mogelijk is om fib x aan te roepen zonder de werking van de functie met tupels te hoeven begrijpen.

In het kort zijn tupels een manier om data op te slaan en door te geven. 

# Lists

Een list kan in tegenstelling tot een tupel maar 1 datatype bevatten. Dit kan ook een list van lists zijn of een list van tupels. De tupels moeten wel dezelfde structuur hebben. 
```
Prelude> let a = [(1, "a", 2) , ("a")]

<interactive>:1:25: error:
    * Couldn't match expected type `(a, [Char], c)'
                  with actual type `[Char]'
    * In the expression: ("a")
      In the expression: [(1, "a", 2), ("a")]
      In an equation for `a': a = [(1, "a", 2), ("a")]
    * Relevant bindings include
        a :: [(a, [Char], c)] (bound at <interactive>:1:5)
```
Bovenstaand voorbeeld mag niet, maar onderstaand voorbeeld mag wel.
```
Prelude> let a = [(1, "a", 2) , (4, "a", 2)]
Prelude> a
[(1,"a",2),(4,"a",2)]
```

De `:` operator kan gebruikt worden om een list in een `head` en `tail` te splitsen of om twee lijsten aan elkaar toe te voegen.
Een voorbeeld waar beide gevallen in gebruikt worden is onderstaande functie om recursief alle even getallen in een lijst terug te geven.
```
allEven :: [Integer] -> [Integer]
allEven [] = []
allEven (h:t) = if even h then h:allEven t else allEven t
```
Regel voor regel zal ik deze functie uitleggen. 
1. Deze regel declareerd de functie allEven met als input een `[Integer]` (lijst van Integer) en output `[Integer]`
2. De functie allEven geeft bij een `[]` (lege lijst) een `[]` tecrug. Dit is de stopconditie. 
3. De functie allEven splits de input in het eerste element, en de rest.  
   Als de functie [even](http://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#v:even) met als input `h` (het eerste element) `true` is voeg dan `h` aan het resultaat van `allEven t` (een lijst met alleen de even getallen) toe en geef dit terug, anders geef `allEven t` terug.
  
## Ranges
Ranges zijn een manier om Haskell een list te laten genereren. De syntax is `[start .. end]` waarbij `start` het eerste nummer is, en `end` het laatste. Standaard zal Haskell stappen van 1 nemen, `[1..4]` wordt dus `[1,2,3,4]`. Het is ook mogelijk om zelf aan te geven met welke stapgrootte hij moet werken. Dit kan door deze syntax te gebruiken. `[first, second .. end]` hierbij wordt het verschil tussen de `first` en `second` waarde gebruikt om de stap groote te bepalen.

## List Comprehensions
List comprehensions is een manier om lijsten te genereren op basis van 3 onderdelen.
1. De expressie
2. De generatoren
3. De filters  
`[Expressie | generator, filter]`
  
   
   
In deze blogpost zijn we dieper op lists ingegaan en hebben we over ranges en list comprehension geleerd. In de volgende blogpost zullen de opgaven voor dag 1 uitgewerkt worden.


***
End of post
***

# Opgaven dag 1
***

# How many different ways can you find to write allEven ?

```Haskell
Prelude> let input = [1..12]
Prelude> [x | x <- input, even x]
[2,4,6,8,10,12]
```

Hiernaast heb ik ook geprobeerd een uitwerking doormiddel van guards te maken, echter lukte dit niet.

# Write a function that takes a list and returns the same list in reverse.

```Haskell
module Reverse where
  myReverse :: [Integer] -> [Integer]
  myReverse [] = []
  myReverse (h:t) = myReverse(t):h
```
Helaas bleek deze oplossing niet te werken. De `:` operator is om een element aan de voorkant van een lijst toe tevoegen, en zoals in dit geval werkt het toevoegen van een lijst aan een nummer niet.
De oplossing hiervoor is het gebruik van de `++` operator. Het resultaat is onderstaande uitwerking.

```Haskell
module Reverse where
  myReverse :: [Integer] -> [Integer]
  myReverse [] = []
  myReverse (h:t) = myReverse(t) ++ [h]
```
Als resultaat:
```Haskell
*Reverse> let list = [1..12]
list :: (Num a, Enum a) => [a]
*Reverse> myReverse list
[12,11,10,9,8,7,6,5,4,3,2,1]
it :: [Integer]
```

# Write a function that builds two-tuples with all possible combinations of two of the colors black, white, blue, yellow, and red. Note that you should include only one of (black, blue) and (blue, black)
```Haskell
Prelude> let colors = ["Black", "White", "Blue", "Yellow", "Red"]
colors :: [[Char]]
Prelude>  [(a, b) | a <- colors, b <- colors, a < b]
[("Black","White"),("Black","Blue"),("Black","Yellow"),("Black","Red"),("White","Yellow"),("Blue","White"),("Blue","Yellow"),("Blue","Red"),("Red","White"),("Red","Yellow")]
it :: [([Char], [Char])]
Prelude> 
```

# Write a list comprehension to build a childhood multiplication table. The table would be a list of three-tuples where the first two are integers from 1–12 and the third is the product of the first two.
```Haskell
Prelude> [(a, b, a*b) | a <- [1..12], b <- [1..12]]
[(1,1,1),(1,2,2),(1,3,3),(1,4,4),(1,5,5),(1,6,6),(1,7,7),(1,8,8),(1,9,9),(1,10,10),(1,11,11),(1,12,12),(2,1,2),(2,2,4),(2,3,6),(2,4,8),(2,5,10),(2,6,12),(2,7,14),(2,8,16),(2,9,18),(2,10,20),(2,11,22),(2,12,24),(3,1,3),(3,2,6),(3,3,9),(3,4,12),(3,5,15),(3,6,18),(3,7,21),(3,8,24),(3,9,27),(3,10,30),(3,11,33),(3,12,36),(4,1,4),(4,2,8),(4,3,12),(4,4,16),(4,5,20),(4,6,24),(4,7,28),(4,8,32),(4,9,36),(4,10,40),(4,11,44),(4,12,48),(5,1,5),(5,2,10),(5,3,15),(5,4,20),(5,5,25),(5,6,30),(5,7,35),(5,8,40),(5,9,45),(5,10,50),(5,11,55),(5,12,60),(6,1,6),(6,2,12),(6,3,18),(6,4,24),(6,5,30),(6,6,36),(6,7,42),(6,8,48),(6,9,54),(6,10,60),(6,11,66),(6,12,72),(7,1,7),(7,2,14),(7,3,21),(7,4,28),(7,5,35),(7,6,42),(7,7,49),(7,8,56),(7,9,63),(7,10,70),(7,11,77),(7,12,84),(8,1,8),(8,2,16),(8,3,24),(8,4,32),(8,5,40),(8,6,48),(8,7,56),(8,8,64),(8,9,72),(8,10,80),(8,11,88),(8,12,96),(9,1,9),(9,2,18),(9,3,27),(9,4,36),(9,5,45),(9,6,54),(9,7,63),(9,8,72),(9,9,81),(9,10,90),(9,11,99),(9,12,108),(10,1,10),(10,2,20),(10,3,30),(10,4,40),(10,5,50),(10,6,60),(10,7,70),(10,8,80),(10,9,90),(10,10,100),(10,11,110),(10,12,120),(11,1,11),(11,2,22),(11,3,33),(11,4,44),(11,5,55),(11,6,66),(11,7,77),(11,8,88),(11,9,99),(11,10,110),(11,11,121),(11,12,132),(12,1,12),(12,2,24),(12,3,36),(12,4,48),(12,5,60),(12,6,72),(12,7,84),(12,8,96),(12,9,108),(12,10,120),(12,11,132),(12,12,144)]
it :: (Num c, Enum c) => [(c, c, c)]
```

# Solve the map-coloring problem
```
Prelude> let states = ["Tennesee", "Mississippi", "Alabama", "Georgia", "Florida"]
states :: [[Char]]
Prelude> let colors = ["Red", "Green", "Blue"]
Prelude> [(state, color) | state <- states, color <- colors]
[("Tennesee","Red"),("Tennesee","Green"),("Tennesee","Blue"),("Mississippi","Red"),("Mississippi","Green"),("Mississippi","Blue"),("Alabama","Red"),("Alabama","Green"),("Alabama","Blue"),("Georgia","Red"),("Georgia","Green"),("Georgia","Blue"),("Florida","Red"),("Florida","Green"),("Florida","Blue")]
it :: [([Char], [Char])]
```
Bovenstaande uitwerking geeft alle states met alle mogelijke colors terug.  Het blijkt echter niet mogelijk om bij list comprehension tussen verschillende entries te filteren, de filters werken alleen op de huidige entry. Om het met list comprehension te doen zal de lijst dus alle states en colors moeten bevatten in 1 entry.
Na wat puzzelen kwam ik helaas niet veel verder, gelukkig stond onderstaande uitwerking online
```Haskell
  colors = ["red", "green", "blue"]
  mapColoring = [ ("Tennesee", t, "Mississippi", m, "Alabama", a, "Georgia", g, "Florida", f) |
                  t <- colors, m <- colors, a <- colors, g <- colors, f <- colors,
                  m /= t, m /= a,
                  a /= t, a /= g, a /= f,
                  g /= f, g /= t ]
```

# Reflectie
De syntax van Haskell begint inmiddels duidelijk te worden. Het functioneel denken lukt voor veel problemen wel, echter blijf ik het vrij lastig vinden. 
Volgende blogpost zal over dag 2 uit het boek gaan.



***
End of post
***

# Spock's Great Strength
***
# Higher-Order Functions
## Anonymous Functions
Een tussen haakjes gedefinieerde functie waarvan de eerste parameter begint met een `\`. Zoals in het boek omschreven:  
`(\param1 .. paramn -> function_body)`

## map and where
### map
Een fuctie die voor elke waarde in een list een functie aanroept. 
```Haskell
map (\x -> x * x) [1, 2, 3]
```
In bovestaand voorbeeld roept map voor elke waarde in `[1,2,3]` de (anonieme) functie `(\x -> x * x)` aan.
### where
Is een manier om een lokale variabele of functie te defineeren. 
### section
Gedeelte van een functie, bijvoorbeeld `+1` dit zal als `x+1` gebruikt worden omdat `+` twee parameters nodig heeft en de eerste mist.
Als voorbeeld:
```Haskell
 map (+ 1) [1, 2, 3]
```

## filter, foldl, foldr
### filter
Een functie die een functie op elke waarde in een lijst toepast. Als de functie true terug geeft blijft de waarde in de lijst, zo niet wordt deze eruit gefilterd.
### foldl, foldr, fold, foldl'
Tja, de titel doet het al vermoeden, functies die allemaal het zelfde doen maar net een beetje anders. Er wordt geen uitleg geven over het nut van deze functies, maar na even googlen kom ik al snel tot de conclusie dat het allemaal functies zijn die een operatie op een lijst uit zouden moeten kunnen voeren. Echter lijken ze allemaal [een probleem](https://wiki.haskell.org/Foldr_Foldl_Foldl') te hebben. Mocht je deze functie dus gebruiken zal je blijkbaar eerst moeten onderzoeken welke van de varianten nou echt gaat werken. Dit is anders dan ik in een taal zoals Java, PHP, JS, Lua of C# gewend ben. Daar heb je een functie die doet wat hij belooft, en als er variates zijn dan is het eind resultaat ook daadwerkelijk anders.

Haskell is blijkbaar erg afhankelijk van deze Higher-Order functions.

# Partially Applied Functions and Currying

> Every function in Haskell has one parameter.

Gelijk een mooi statement om het hoofdstuk mee te openen. In het hoofdstuk Anonymous Functions heb ik volgens mij duidelijk laten zien dat een functie n parameters kon hebben... Blijkbaar bevat Haskell een process genaamd Currying, dit process maakt van een functie met meerdere parameters functies met maar 1 parameter. 

`let sum x y = x + y` bevat twee parameters, maar aangezien Haskell alleen maar met functies met 1 parameter werkt zal hij deze functie ombouwen. Bij de aanroep `sum 1 2` wordt dit eerst een anonieme functie namelijk: `(\y -> 1 + y)`, deze wordt vervolgens met als parameter 2 uitgevoerd. 

Het maximum van 1 parameter is een limitatie waar ik nooit aan gedacht had, maar het is achteraf gezien ook niet zo'n limiteerende factor, zeker gezien Haskell dit alleen "onder water" heeft. 

# Lazy Evaluation
Een beetje het zelfde principe als bijvoorbeeld lazy loading van plaatjes op een website. "Ik ga alleen iets uitwerken als daar specifiek om gevraagd word"
In Haskell uit Lazy Evaluation zich in bijvoorbeeld infinite lists. De range syntax die we al eerder gezien hebben: `[1..12]` kon ook geschreven worden als `[1,2..12]` sterker nog de `12` kon weggelaten worden: `[1,2..]` een range die oneindig door gaat. Doormiddel van de functie `take` konden we de lengte die we wilden hebben bepalen.
```Haskell
Prelude> take 5 [1,2..]
[1,2,3,4,5]
it :: (Num a, Enum a) => [a]
```
Het zelf maken van een infinite list is eigenlijk een recusieve functie zonder stopconditie... Klinkt als een slecht idee, maar werkt in combinatie met de functies [take en drop](http://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#v:take) wel.


In deze blogpost zijn een aantal interessante concepten voorbij gekomen. Ik heb het gevoel dat ik de basis van Haskell redelijk door heb... Of dat echt zo is zullen we in de volgende blogpost bij de uitwerkingen van de opgaven zien.

***
End of post
***

# Opgaven Dag 2
***

# Write a sort that takes a list and returns a sorted list.

```
module MySort where
  mySort [] = []
  mySort (h:t) = (mySort k) ++ [h] ++ (mySort g)
    where
      k = filter (< h) t
      g = filter (> h) t
```

Deze implementatie lijkt op de Quicksort en Mergesort die wij in de course behandeld hebben, hij blijft het probleem verkleinen totdat er lijsten van 1 groot zijn, deze worden samengevoegd en uiteindelijk is lijst hierdoor gesorteerd. 

# Write a sort that takes a list and a function that compares its two arguments and then returns a sorted list.  

Deze vraag heb ik oprecht een tijd overnagedacht en ik heb hier geen oplossing voor. 

#  Write a Haskell function to convert a string to a number. The string should be in the form of $2,345,678.99 and can possibly have leading zeros.

```
module ToDouble where
  toDouble (h:t) = read (filter (/= ',') t) :: Double
```
Door het gebruik van [de read function](http://zvon.org/other/haskell/Outputprelude/read_f.html) is het mogelijk om een string naar een ander datatype te casten. Echter werkt deze functie niet met komma's. Een string is een lijst van characters, met de filter functie worden alle komma characters dus uit de lijst gefiltered.

# Write a function that takes an argument x and returns a lazy sequence that has every third number, starting with x . Then, write a function that includes every fifth number, beginning with y. Combine these functions through composition to return every eighth number, beginning with x + y.

```
module Multiples where
    multiples x y = [x, x+y ..]
    threes = take 5 (multiples 1 3)
    fives = take 5 (multiples 1 5)
    eights = zipWith (+) threes fives
```
Deze opgave was relatief makkelijk, echter begreep ik niet wat er met de laatste zin bedoeld werd... [hier](https://github.com/kikito/7-languages-in-7-weeks/blob/master/7-haskell/day-2/lazy.hs) is een uitwerking van iemand andres, daar werd de zipWith functie gebruikt. Ik betwijfel of dit de bedoeling was, maar het lijkt te werken. ish...

# Use a partially applied function to define a function that will return half of a number and another that will append \n to the end of any string.


```
module Partially where
  halve x = (x/2) 
  append x = reverse ('n':'\\':(reverse x))
```

## Halve
geeft x / 2 terug... Spreekt inmiddels voor zich.

## Append
Aangezien de : operator alleen aan het begin van een lijst toe kan voegen moet de lijst eerst omgedraaid worden. Na het toevoegen draait de lijst weer om waardoor het lijkt alsof de "\\n" aan het einde is toegevoegd. 

# Reflectie

De opgave voor deze dag vielen mee. De enige opgave waar ik niet uit kom zal ik wel te moeilijk over denken / niet begrijpen. Volgende post gaat over de laatste dag uit het boek. 


***
End of post
***

# The Mind Meld
***

Het laatste hoofdstuk uit het boek. Ik merk tot nu toe dat de materie steeds complexer wordt. Ik hoop dat ik dit hoofdstuk nog ga begrijpen want van wat ik gehoord heb is deze vrij pittg.  

# Classes and Types

De basic types hebben wij al tijdens de eerste blog gezien, als korte herhaling zijn bijvoorbeeld een Bool en Char primitive types. Een String is een lijst van Char.

## User-Defined Types

Het is in Haskell mogelijk om zelf een Type te definieren, dit gaat doormiddel van onderstaande syntax
```
data %name% = Type (| Type)
```
waarbij `%name%` aangeeft hoe het type moet gaan heten.
Het is verplicht minimaal 1 ander Type aan te geven waaruit jou Type kan bestaan. Met het `|` teken kan je aangeven dat jou type uit één de aangegeven Types kan bestaan. Een Tupel of Lijst is ook een type. Het is dus mogelijk om bijvoorbeeld de volgende Type te definieren:
```
type Adres = (String, Number)
```
Een adres bestaat nu dus uit een tupel met daarin een String (straatnaam) en Number (huisnummer). String en Nummer zijn beide echter geen primitieve waarde. Het Type systeem van Haskell vertaald uiteindelijk alle types naar primitieve waarden.

## Recursieve Types

Het is in Haskell ook mogelijk om een recursief type te definieren. In de lessen hebben wij tijdens het bouwen van een grammatica iets gezien wat hier op lijkt. Bijvoorbeeld een som, een som is een samenvoeging van twee getallen, maar een som kan ook een getal en een resultaat van een andere som samenvoegen. In haskell zou dat er ongeveer zo uit zien. (deze som is niet berekend maar geeft alleen twee waardes die samengevoegd zouden moeten worden)

```
data Tellable = Tell Integer | Som deriving (Show)
data Som = TelOp Tellable Tellable deriving (Show)
```

Helaas is het mij niet gelukt om dit voorbeeld werkend te krijgen.

## Classes
maar dan niet in de Object Orientend manier. Mocht je het toch met OO willen vergelijken dan komt een Interface nog het dichtste bij. Een Class is een Type die een implementatie voor alle function signatures heeft. Het boek gaat niet verder op een uitwerking in.

## Monads
Eindelijk een compleet nieuwe term.
>  But you’ll probably find that you need to wade through several examples from many different sources to come to an understanding of what monads can dofor you.
Helaas zal ik het alleen met dit boek moeten doen door gebrek aan tijd. 

In javascript ben ik het vaker tegengekomen dat je een functie een reference naar een variabele meegeeft, de functie bewerkt de variabele per referentie. [Artikel hier over](https://codeburst.io/javascript-pass-by-value-and-pass-by-reference-in-javascript-fcf10305aa9c) Het voorbeeld uit het boek met de piraat zou er dus ook zo uit zien:
```
-- d is een object met daar in een nummer en kan dus als reference meegegeven worden
stagger(d)
crawl(d)
stagger(d)
```

In haskell bestaan echter geen referenties op deze manier en kan je bovenstaande code niet zo uitdrukken. In haskell zal je verder moeten met de waarde van de vorige functie. Dus:
```
stagger(crawl(stagger(d)))
```
of
```
letTreasureMap (v, d) = let d1 = stagger d
d2 = stagger d1
d3 = crawl d2
in d3
```

De oplossing om dit mooier te maken is een Monad. Oftewel " a monad lets us compose functions in ways that have specific properties".
### De uitwerking
```Haskell
module Main where
  data Position t = Position t deriving (Show)
  stagger (Position d) = Position (d + 2)
  crawl (Position d) = Position (d + 1)
  rtn x = x
  x >>== f = f x
```
Als ik dit zie denk ik dat de definitie van mooi toch afwijkt van wat ik in gedachte had, maar goed bovenstaande is dus een hele simpele Monad. Het gebruik van de Monad gaat als volgt:
```HASKELL
treasureMap pos = pos >>==
  stagger >>==
  stagger >>==
  crawl >>==
  rtn
```  
Na redelijk wat tijd en [andere bronnen](https://www.haskell.org/tutorial/monads.html) heb ik nu wel een idee hoe deze monad werkt, hoop ik. Ik begrijp waarom dit een lastig concept is. Ik ga het proberen in eigen woorden uit te leggen.
De monad bestaat uit 3 onderdelen.  
1. De container, oftewel iets wat een waarde kan houden, bijvoorbeeld een lijst of nummer. In bovenstaand voorbeeld een `Position` die waarde `t` kan houden.  
1. Een return functie die de waarde in je monad teruggeeft. 
1. Een functie die andere functies in de monad aan elkaar kan koppelen.
Deze onderdelen samen vormen een Monad. Het voordeel van een Monad is dat je de functies achter elkaar aan kan roepen (composition) in plaats van moet nesten.

## Do
Een andere notatie voor een monad kan met een `do` bijvoorbeeld:
```
module Main where
  tryIo = do putStr "Enter your name: " ;
             line <- getLine ;
             let { backwards = reverse line } ;
             return ( "Hello. Your name backwards is " ++ backwards)
```
Als oefening probeerde ik deze monad om te schrijven naar een monad van de andere notatie. Dit is wat ik dacht dat het zou moeten zijn:
```
module Mon where 
    data Output t = Output t deriving (Show)
    getl (Output d) = Output(getLine : d)
    rtn x = "Your name is" ++ x
    x >>== f = f x
```
Helaas blijkt dit niet te werken omdat getLine een `IO String` terug geeft en `Your name is` is een `[char]` En deze kunnen helaas niet samengevoegd worden. 

## Maybe Monad
Een probleem in de software wereld is dat je niet altijd zeker bent wat je terug gaat krijgen. Denk bijvoorbeeld aan een array waar een element uit wilt halen. In java kan dit die waarde teruggeven, of je krijgt een leuke null pointer Exception. In haskell is alles strongly typed, je weet exact wat een functie neemt en geeft, echter zijn er ook dingen die onzeker blijven: daarvoor is de Maybe Monad. Gelukkig is er in Haskell een type voor: Just. Just kan een van twee dingen zijn: Nothing of x. 
```HASKELL
data Maybe a = Nothing | Just a
instance Monad Maybe where
  return = Just
  Nothing >>= f = Nothing
  (Just x) >>= f = f x
```

# Reflectie
En daarmee is alles uit het boek van Haskell besproken. Volgende blog zal ik een poging tot de opgave van deze dag proberen, na even vooruit gekeken te hebben zie ik hier behoorlijk tegen op. Ik heb het idee dat ik het concept van een Monad snap, maar de "big picture" van haskell zelf nog mis. In een OO taal als Java weet ik hoe ik een probleem aan kan pakken, bij Haskell weet ik niet eens waar ik zou moeten beginnen. 

## Haskell
Een van de sterke kanten van Haskell is het Type systeem, een functie geeft duidelijk aan wat hij krijgt en geeft. Dit vind ik fijner dan bijvoorbeeld Javascript waar een variabele alles kan zijn, echter werkt dit ook tegen, bijvoorbeeld met de getLine functie om de console uit te lezen, dit geeft een IO String terug en kan dus niet gebruikt worden met functies die een [char] verwachten. Daarnaast vind ik de syntax van Haskell nog steeds verschikkelijk. De namen van functies zijn vaak onduidelijk en bij `Just Position (Coordinate x)` kan ik niet zien wat nou een functie, Monad, Type of Class is. De denkwijze van Haskell is compleet anders dan Object Oriented, wat te verwachten was, helaas heb ik dit semester niet veel tijd om verder te gaan met deze taal. Het schrijven van deze blogposts ,tot nu toe, heeft veel tijd gekost. De titel 7 languages in 7 weeks ben ik het niet mee eens, alleen deze language heeft al 4 weken gekost en ik heb niet het idee dat ik in staat ben deze taal in de praktijk toe te passen. Wellicht dat dit na de opdrachten van dag 3 en de "challenge" nog gaat veranderen.    


***
End of post
***

# Opgaven Dag 3
***

# Hashmap
Na wat basis zoekwerk lijkt het er op dat Haskell al een module voor een [HashTable](https://hackage.haskell.org/package/base-4.2.0.2/docs/Data-HashTable.html) heeft. Gezien het bij dit onderwerp over Maybe Monads gaat vermoed ik dat het de bedoeling is deze te gebruiken in plaats van zelf een implementatie voor een HashTable te maken.

> Write a function that looks up a hash table value that uses the Maybe monad. Write a hash that stores other hashes, several levels deep. Use the Maybe monad to retrieve an element for a hashkey several levels deep.

```HASKELL
module Hashed where 
  import Data.Map (Map)
  import qualified Data.Map as Map
  
  ages :: Map String Integer
  ages = Map.fromList [("Joe", 35), ("Mary", 37), ("Irma", 16)]
  
  findAge :: String -> String
  findAge name = case Map.lookup name ages of
                 Nothing  -> "I don't know the age of " ++ name ++ "."
                 Just age -> name ++ " is " ++ show age ++ " years old."
```
Bovenstaande code is een verbetering van de code in [dit stackoverflow antwoord (waar ik de code ook weer verbeterd heb).](https://stackoverflow.com/a/20505647) Die code is al in staat om in de functie `findAge` een Maybe Monad te gebruiken en als mogelijk de value bij een key terug te geven. 
```HASKELL
module Hashed where 
  import Data.Map (Map)
  import qualified Data.Map as Map
  
  ages :: Map String Integer
  ages = Map.fromList [("Joe", 35), ("Mary", 37), ("Irma", 16)]
  
  findAge :: String -> String
  findAge name = case Map.lookup name ages of
                 Nothing  -> "I don't know the age of " ++ name ++ "."
                 Just age -> name ++ " is " ++ show age ++ " years old."

  nestedHashes :: Map String String
  nestedHashes = Map.fromList [("Hello", "World"), ("World", "This"), ("This", "That"), ("That", "Foo"), ("Foo", "Bar"), ("Adam", "Savage")]
  
  findHashed :: String -> String
  findHashed hash = case Map.lookup hash nestedHashes of
                 Nothing -> hash
                 Just string -> findHashed(show string)
```

Bovenstaande uitwerking is een uitbreiding op de eerste, deze heeft een functie `findHashed` die door gebruik van een Maybe Monad net zo lang door een HashTable blijft gaan totdat hij niet meer dieper kan. Echter denk ik niet dat ik het Hash gedeelte hier juist in verwerkt heb aangezien dit ook met een gewone Map zou kunnen, maar op de [hackage](http://hackage.haskell.org/package/hashmap-1.3.3/docs/Data-HashMap.html#t:Map) pagina staat dat een HashMap deprecated is en je een Map moet gebruiken. Ik denk dat het deze oplossing niet helemaal is wat er bedoeld was, maar ik vind hem voldoende.

# Maze
>  Represent a maze in Haskell. You’ll need a Maze type and a Node type, as well as a function to return a node given its coordinates. The node should have a list of exits to other nodes.

Voordat ik aan deze opdracht begin: Deze (samen met de volgende) opdracht klinkt lastiger dan wat ik als Challenge zou doen, ik heb bijna geen idee waar ik zou moeten beginnen, laat staan een algoritme schrijven die dit kan oplossen.

Als eerste is het bepalen wat een Maze nou eigenlijk is. Volgens de opdracht is een Maze een type, en een Node is een type met een lijst van exits. Ook moet er een functie zijn die op basis van coordinaten een Node terug kan geven. Hieruit kan ik concluderen dat de lijst van exits dus een lijst van de coordinaten van de volgende nodes zijn. `node = [Exit]` De exit was de locatie van de volgende node, oftewel een coordinaat `Exit = (Int, Int)`. De maze zou volgens mij een Map kunnen zijn waarbij de Exit de key van een Node kan zijn. `Maze = Map Exit Node`. Dat zou er dan volgens mij zo uit moeten komen te zien:
```HASKELL
module Maze where 
  import Data.Map (Map)
  import qualified Data.Map as Map
  
  type Exit = (Int, Int)
  type Node = Maybe [Exit]
  
  maze :: Map Exit Node
  maze = Map.fromList [((0, 0), Just [(0,1), (1,0)]), ((1,0), Nothing), ((0,1), Just [(1,1), (0,2)]), ((1,1), Nothing), ((0,2), Just [(0,3)]), ((0,3), Just [(0,4), (1,4)]), ((0,4), Nothing), ((1,4), Just [(1,5)]), ((1,5), Nothing)]
```
(De rest van deze blog is geschreven nadat de uitwerking van de maze niet werkte en met een groep tijdens de les is besproken)

## De maze laten oplossen. 
>  Use a List monad to solve the maze.  

Kijk dat is lekker simpel! Even een algorimte in een nieuwe taal uitwerken waarbij ik de syntax soms nog nauwlijks snap... Goed, wie niet waagt wie niet wint. De maze zoals hierboven beschreven is slechts in een richting te lopen, ik hoef mij dus geen zorgen te maken dat het algorimte in een loop zal komen. Om de maze op te lossen zal een recursieve oplossing gebruiken. Onderstaand is de uitwerking in pseudocode:
```PSEUDO
  solveNode:
    (als "de node" geen exits heeft geef geen oplossing terug)
    voor de eerste Exit van "de node" controleer of deze de eindbestemming is,
      zo ja: geef deze Exit terug.
      zo nee: Probeer "de Exits" van deze Exit te vinden.
              als die er niet zijn: Probeer de volgende Exit van "de node"
              als die er wel zijn: Probeer solveNode met "de Exits"
                      als solveNode geen oplossing geeft: probeer de volgende Exit van "de node"
                      als solveNode wel een oplossing geeft: voeg de Exit van "de node" aan het resultaat toe
```
in Haskell ziet dat er dan zo uit. De functie `solveMaze` is een wrapper die er voor zorgt dat je met de locatie van de eerste node kan beginnen in plaats van met de exits van de eerste node. `start`, `middle` en `exit` zijn 3 locaties van nodes om makkelijk de functies aan te kunnen roepen. E.G. `solveMaze start maze end`
```HASKELL
module Maze where
  import Data.Map (Map)
  import qualified Data.Map as Map
  
  type Exit = (Int, Int)
  type Node = Maybe [Exit]
  type Maze = Map Exit Node
  
  maze :: Maze
  maze = Map.fromList [((0, 0), Just [(0,1), (1,0)]), ((1,0), Nothing), ((0,1), Just [(1,1), (0,2)]), ((1,1), Nothing), ((0,2), Just [(0,3)]), ((0,3), Just [(0,4), (1,4)]), ((0,4), Nothing), ((1,4), Just [(1,5)]), ((1,5), Nothing)]
  
  getNode :: Exit -> Maze -> Maybe [Exit]
  getNode location maze = case Map.lookup location maze of
                 Nothing -> Nothing
                 Just nde -> nde


  solveMaze :: Exit -> Maze -> Exit -> [Exit]
  solveMaze start m finish = case getNode start m of
                                  Nothing -> []
                                  Just n -> case solveNode n m finish of
                                            Nothing -> []
                                            Just solution -> solution
                                  
  solveNode :: [Exit] -> Maze -> Exit -> Maybe [Exit]
  solveNode [] _ _ = Nothing
  solveNode (h:t) m finish = if h == finish
                             then Just [finish]
                             else case getNode h m of
                                  Nothing -> solveNode t m finish
                                  Just n ->  case solveNode n m finish of
                                             Nothing -> Nothing
                                             Just e -> Just (h:e)
  start :: Exit
  start = (0, 0)
  
  middle :: Exit
  middle = (0, 2)
  
  end :: Exit
  end = (1, 5)
```

De aanroep `solveMaze start maze end` geeft terug 
```
*Maze> solveMaze start maze end
[(0,1),(0,2),(0,3),(1,4),(1,5)]
it :: [Exit]
```
hij heeft dus een oplossing gevonden!
## Een grotere maze!
Nu het algoritme lijkt te werken is het tijd om het wat lastiger te maken.
```MAZE
((0,0), [(0,1)]),
((0,1), [(0,2)]),
((0,2), [(1,2)]),
((1,2), [(1,3), (2,2)]),
((1,3), [(1,4)]),
((1,4), [(2,4)]),
((2,0), Nothing),
((2,2), [(3,2)]),
((2,4), [(3,4)]),
((3,0), [(2,0), (4,0)]),
((3,1), [(3,0)]),
((3,2), [(3,1), (3,3), (4,2)]),
((3,3), [(3,4)]),
((3,4), [(3,5)]),
((3,5), [(4,5)]),
((4,0), Nothing),
((4,2), [(5,2)]),
((4,5), [(5,5)]),
((5,1), [(6,1)]),
((5,2), [(5,1)]),
((5,4), [(6,4)]),
((5,5), [(5,4)]),
((6,0), Nothing),
((6,1), [(6,0)]),
((6,3), Nothing),
((6,4), [(6,3)])
```
Bovenstaande is een mooie definitie van een maze, maar om je te helpen is hieronder een visualisatie van die definitie. 
![Maze](/Haskell/images/maze.jpeg)
Bovenstaande maze is in Haskell te gebruiken met de volgende code:
```HASKELL
  largeMaze :: Maze
  largeMaze = Map.fromList [((0,0), Just [(0,1)]), ((0,1), Just [(0,2)]),((0,2), Just [(1,2)]),((1,2), Just [(1,3), (2,2)]),((1,3), Just [(1,4)]),((1,4), Just [(2,4)]),((2,0), Nothing),((2,2), Just [(3,2)]),((2,4), Just [(3,4)]),((3,0), Just [(2,0), (4,0)]),((3,1), Just [(3,0)]),((3,2), Just [(3,1), (3,3), (4,2)]),((3,3), Just [(3,4)]),((3,4), Just [(3,5)]),((3,5), Just [(4,5)]),((4,0), Nothing),((4,2), Just [(5,2)]),((4,5), Just [(5,5)]),((5,1), Just [(6,1)]),((5,2), Just [(5,1)]),((5,4), Just [(6,4)]),((5,5), Just [(5,4)]),((6,0), Nothing),((6,1), Just [(6,0)]),((6,3), Nothing),((6,4), Just [(6,3)])]
```
Het draaien van `solveMaze (0,0) largeMaze (6,0)` op deze largeMaze geeft 
```
*Maze> solveMaze (0,0) largeMaze (6,0)
[(0,1),(0,2),(1,2),(2,2),(3,2),(4,2),(5,2),(5,1),(6,1),(6,0)]
it :: [Exit]
```
En dat klopt!
# Conclusie
Hoewel deze opgaven als zeer lastig op mij over kwamen ben ik er wel trots op dat ik deze heb weten op te lossen. Ik weet niet zeker of de hashtable opgave gemaakt is zoals bedoeld, maar de maze opgave(n) zijn zeker goed. De solveNode heeft veel moeite gekost om werkend te krijgen, echter is het na kritsch kijken met een groep wel gelukt. Het bedenken van de pseudocode viel wel mee, maar ik bleef vastlopen op verschillende Type errors. De Haskell compiler geeft wel aan wat hij krijgt en wat hij verwacht, maar dat vond ik toch lastig om te vertalen naar de locatie van het daadwerkelijke probleem. Dit doet mij wel denken aan het leren van Object Oriented programmeren in Java, daarbij kreeg je in de console ook errors als NullPointerException zonder dat ik wist waar dat door kon komen. Haskell vind ik een interessante taal, echter blijf ik de syntax zoals eerder in deze blog omschreven onduidelijk vinden. De opgave in het boek ben ik niet altijd uit gekomen, en zoals in het boek omschreven staat heeft Haskell geen grote community, hierdoor vond ik het ook vaak lastig om de antwoorden te vinden op problemen die ik tegen kwam. 

## TLDR
Pure taal, lastig te leren en onduidelijke syntax.


***
End of post
***
Deze blog was ook te lezen op http://github.io/IBlackI/Haskell
